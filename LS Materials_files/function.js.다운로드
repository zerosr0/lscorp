var aathumimg = new Image();
var CompanyKey="indam";
var imageWindow;


function comma(n) {
 var reg = /(^[+-]?\d+)(\d{3})/;
  n += '';                        

  while (reg.test(n))
    n = n.replace(reg, '$1' + ',' + '$2');

  return n;
}

function numonly(n) {
	var n1;
	
	if(n.length > 2) 
	{
		n1=n.replace(/,/g,'');
	}else{
		if(n == "")
		{
			n=0;
		}
		n1=n;
	}
  	return parseInt(n1);
}

function get_num(n) {
	var n1;
	if(!n)
	{
		return 0;
	}
	n=n.toString();
	if(n.length > 0 ) 
	{
		n1=n.replace(/[^0-9-]/g,'');
	}else{
		if(n == "")
		{
			n=0;
		}
		n1=n;
	}
	if((n1 == "") || (n1 == '-'))
	{
		n1=0;
	}
  	return parseInt(n1);
}

function trimstr(str){
   //정규 표현식을 사용하여 화이트스페이스를 빈문자로 전환
   str = str.replace(/^\s*/,'').replace(/\s*$/, ''); 
   return str; //변환한 스트링을 리턴.
}

function pause(numberMillis) {
     var now = new Date();
     var exitTime = now.getTime() + numberMillis;

     while (true) {
          now = new Date();
          if (now.getTime() > exitTime)
              return;
     }
}


function allChk(obj,f) {
	var el = f.elements['list[]'];
	if (el) {
		var chk = obj.checked;

		if (!el.length) {
			el.checked = chk;
		}
		else {
			for (var i = 0 ; i < el.length ; i++) {
				el[i].checked = chk;
			}
		}
	}
}

function SearchSubmit(n)
{

	for(var i=0;i<document.IndexSearchForm.length;i++)
	{


		if(document.IndexSearchForm[i].name.indexOf("hide_") >= 0)
		{
			
			//document.IndexSearchForm[i].disabled=true;
		}

	}
	document.IndexSearchForm.submit();
}

function allDelCheck(f) {
	var con = confirm('정말 삭제하시겠습니까?');

	if(con === true)
		f.submit();
}



function auto_fit_size() {//팝업창 자동조절
    window.resizeTo(100, 100);
    var thisX = parseInt(document.body.scrollWidth);
    var thisY = parseInt(document.body.scrollHeight);
    var maxThisX = screen.width - 50;
    var maxThisY = screen.height - 50;
    var marginY = 0;
    //alert(thisX + "===" + thisY);
    //alert("임시 브라우저 확인 : " + navigator.userAgent);
    // 브라우저별 높이 조절. (표준 창 하에서 조절해 주십시오.)
    if (navigator.userAgent.indexOf("MSIE 6") > 0) marginY = 90;        // IE 6.x
    else if(navigator.userAgent.indexOf("MSIE 7") > 0) marginY = 100;    // IE 7.x
    else if(navigator.userAgent.indexOf("Firefox") > 0) marginY = 90;   // FF
    else if(navigator.userAgent.indexOf("Opera") > 0) marginY = 80;     // Opera
    else if(navigator.userAgent.indexOf("Netscape") > 0) marginY = -2;  // Netscape
    else marginY = 100;  // Netscape

    if (thisX > maxThisX) {
        window.document.body.scroll = "yes";
        thisX = maxThisX;
    }
    if (thisY > maxThisY - marginY) {
        window.document.body.scroll = "yes";
        thisX += 19;
        thisY = maxThisY - marginY;
    }
    window.resizeTo(thisX+10, thisY+marginY);
}



function open_image(url){
	aathumimg.src = url;
	var imgW = aathumimg.width;
	var imgH = aathumimg.height;
	var imageWindow2;
	if((imgW!=0) && (imgH!=0))
	{
		imageWindow2=window.open(url,'imageWindow','width='+imgW+', height='+imgH+', scrollbars=no');
		imageWindow2.focus();
	}
}


function initOption( selectObjId )
{
	var selectObj = document.getElementById( selectObjId );
	if ( selectObj == null ) return; 
	selectObj.options.length = 0;
}

function createOption( text, value )
{
	var oOption = document.createElement("OPTION");
    oOption.text = text;
	oOption.value = value;
	return oOption;
}
    

function addOption( selectObjId, keywordObjId, valueObjId )
{
	var selectObj = document.getElementById( selectObjId );    
    if ( selectObj == null) return; 
    selectObj.add( createOption( keywordObjId ,valueObjId ) );   
}

function setCookie( cookieName, cookieValue, expireDate )
{
	var today = new Date();
	today.setDate( today.getDate() + parseInt( expireDate ) );
	document.cookie = cookieName + "=" + escape( cookieValue ) + "; path=/; expires=" + today.toGMTString() + ";";
}

function getCookie( cookieName )
{
  var search = cookieName + "=";
  var cookie = document.cookie;

  if( cookie.length > 0 )
  {
   startIndex = cookie.indexOf( cookieName );
   if( startIndex != -1 )
   {
	startIndex += cookieName.length;
    endIndex = cookie.indexOf( ";", startIndex );
    if( endIndex == -1) endIndex = cookie.length;
		return unescape( cookie.substring( startIndex + 1, endIndex ) );
   }else{
	return false;
   }
  }
  else
  {
   return false;
  }
}

function deleteCookie( cookieName )
 {
  var expireDate = new Date();
  
  expireDate.setDate( expireDate.getDate() - 1 );
  document.cookie = cookieName + "= " + "; expires=" + expireDate.toGMTString() + "; path=/";
 }

function LoginCheck()
{
	var f=document.IndexForm;
	var  y;
		
	if(f.user_id.value == "")
	{
		alert('아이디를 입력하세요');
		return false;
	}
		
	if(f.user_pw.value == "")
	{
		alert('비밀번호를 입력하세요');
		return false;
	}
		
	y="&menucat=members";
	y=y+"&mode=login";
	y=y+"&user_id="+f.user_id.value;
	y=y+"&user_pw="+f.user_pw.value;
	y=y+"&login="+f.login.value;
	y=y+"&hide_tyuijdtw="+f.hide_tyuijdtw.value;
	
	$.ajax({
		url : '../_ma_post/loginPost.php',
		type : 'POST' ,
		data :y,
		success : function (result) {
			a=result.split("|");

			if (parseInt(a[0]) == 1) {
				if(f.loginmain.checked == true)
				{
					//if(getCookie("v7style_id") == false)
					//{
						//deleteCookie("v7style_id");
					//deleteCookie("v7style_pw");
						setCookie("madmmaroo_id",f.user_id.value,86400*30);
						setCookie("madmmaroo_pw",f.user_pw.value,86400*30);
					//}
				}else{
					deleteCookie("madmmaroo_id");
					deleteCookie("madmmaroo_pw");
				}
				location.href=a[2];
			}else{
				alert(a[1]);
			}
		},
		error: function(e) {
    		alert('connect error','ERROR');
    	}
	});
}

function EnterKey(n,m)//n 옵션 m 파라미터
{
	if(event.keyCode == 13)
	{
		if(n == 1)
		{
			LoginCheck();
		}	
	}
}



function LinkCopy(n)
{
	/*var rSource=document.CopyForm["SourceLink"+n];
 	/*rSource.select()
  	if(window.clipboardData)
  	{ 
  		var r=clipboardData.setData('Text',rSource.value); 
  		return 1; 
  	}else{
  		
  	}* /
  	
  	var tempval=rSource; 
    tempval.focus(); 
    tempval.select() ;
    therange=tempval.createTextRange();
    therange.execCommand("Copy") ;
	alert ('클립보드에 복사되었습니다. Ctrl+V로 붙히기 하세요');	*/
	
	$('#clip_target').select();
    var IE=(document.all)?true:false;
    if (IE) 
    {
        window.clipboardData.setData("Text", n);
    } else {
        temp = prompt("이 글의 트랙백 주소입니다. Ctrl+C를 눌러 클립보드로 복사하세요", n);
    }
}

function LinkCopyEn(n)
{
	/*var rSource=document.CopyForm["SourceLink"+n];
 	/*rSource.select()
  	if(window.clipboardData)
  	{ 
  		var r=clipboardData.setData('Text',rSource.value); 
  		return 1; 
  	}else{
  		
  	}* /
  	
  	var tempval=rSource; 
    tempval.focus(); 
    tempval.select() ;
    therange=tempval.createTextRange();
    therange.execCommand("Copy") ;
	alert ('클립보드에 복사되었습니다. Ctrl+V로 붙히기 하세요');	*/
	
	$('#clip_target').select();
    var IE=(document.all)?true:false;
    if (IE) 
    {
        window.clipboardData.setData("Text", n);
    } else {
        temp = prompt("This is the trackback address for this article. Press Ctrl + C to copy to clipboard", n);
    }
}

function LinkCopyVn(n)
{
	/*var rSource=document.CopyForm["SourceLink"+n];
 	/*rSource.select()
  	if(window.clipboardData)
  	{ 
  		var r=clipboardData.setData('Text',rSource.value); 
  		return 1; 
  	}else{
  		
  	}* /
  	
  	var tempval=rSource; 
    tempval.focus(); 
    tempval.select() ;
    therange=tempval.createTextRange();
    therange.execCommand("Copy") ;
	alert ('클립보드에 복사되었습니다. Ctrl+V로 붙히기 하세요');	*/
	
	$('#clip_target').select();
    var IE=(document.all)?true:false;
    if (IE) 
    {
        window.clipboardData.setData("Text", n);
    } else {
        temp = prompt("Đây là địa chỉ 'trackback' cho bài viết này. Hãy nhấn Ctrl+C để sao chép nó vào bộ nhớ tạm thời", n);
    }
}


function LinkCopy2(n,m)
{
	var rSource=n

  	if(window.clipboardData)
  	{ 
  		var r=clipboardData.setData('Text',n[m].value); 
  	}else{
  		
  	}

	alert ('클립보드에 복사되었습니다. Ctrl+V로 붙히기 하세요');	
}


function ArrayMatch(str1,str2,spt)//배열 매치 체크박스에서 사용
{
	var el=new Array();
	var i;
	if(str2.trim() != "")
	{
	el=str2.split(spt);
	if(el.length)
	{
		for(i=0;i<el.length;i++)
		{
			if(el[i].trim() == str1)
			{
				return true;
			}
		}
	}else{
	
		if(str2.trim() == str1.trim())
		{
			return true;
		}
	}
	return false;
	}else{
		return false;
	}
}


function cookieVal(cookieName) {
	thisCookie = document.cookie.split("; ");

	for(i=0; i<thisCookie.length; i++) {
		if(cookieName == thisCookie[i].split("=")[0]) {
			return thisCookie[i].split("=")[1];
		}
	}

	return "x";
}
function popup_1(no, width, height) {
	var url = "popup.html?no="+no;
	var name = "popup"+no;
	var opt = "width="+width+",height="+height;

	if(cookieVal("popup"+no) != "1") {
		CenterWin(url,name,opt);
	}
}

function popup_2(no, width, height, top, left) {
	var url = "popup.html?no="+no;
	var name = "popup"+no;
	var opt = "scrollbars=1,width="+width+",height="+height+",top="+top+",left="+left;

	if(cookieVal("popup"+no) != "1") {
		window.open(url,name,opt);
	}
}

function CenterWin(url,winname,features) {
	features = features.toLowerCase();
	features.replace(' ','');
	sp = new Array();
	sp = features.split(',', 10);
	splen = sp.length;
	for (i=0; i < splen; i++) {
		if (sp[i].indexOf("width=") == 0) {
			width = Number(sp[i].substring(6));
		}
		else if (sp[i].indexOf("height=") == 0) {
			height = Number(sp[i].substring(7));
		}
	}

	sleft = (screen.width - width) / 2;
	stop = (screen.height - height) / 2;
	features = features + ",left=" + sleft + ",top=" + stop;
	window.open(url, winname, features);
}

function lentcateChg(f, tg, md) {
	//register,edit,del
	var cnameObj = f.elements['lentcat'+tg];
	var selObj1 = f.elements['lentsel1'];
	var selObj2 = f.elements['lentsel2'];
	var selObj3 = f.elements['lentsel3'];
	//등록 수정 삭제 별로 체크
	if (md == 'register' && tg == 2) {
		if (selObj1.selectedIndex < 0) {
			alert('대분류를 선택해주세요');
			return;
		}
	}else if (md == 'register' && tg == 3) {
		if (selObj2.selectedIndex < 0) {
			alert('중분류를 선택해주세요');
			return;
		}
	}else if (md != 'register') {
		if (tg == 1) {
			if (selObj1.selectedIndex < 0) {
				alert('수정,삭제 하실 대분류를 선택해주세요');
				return;
			}
		}else if (tg == 2) {
			if (selObj2.selectedIndex < 0) {
				alert('수정,삭제 하실 중분류를 선택해주세요');
				return;
			}
		}
		else {
			if (selObj3) {
				if (selObj3.selectedIndex < 0) {
					alert('수정,삭제 하실 소분류를 선택해주세요');
					return;
				}
			}		
		}
	}

	if (md == 'del') {
		if(!confirm('정말 삭제하시겠습니까?')) {
			return;
		}
	}
	else {
		if (!cnameObj.value.trim()) {
			alert('분류명을 입력해주세요');
			cnameObj.focus();
			return;
		}
	}

	f.elements['mode'].value = md;
	f.elements['cate_level'].value = tg;
	f.elements['cat_len'].value = f.elements['lentsel'+tg].options.length;
	f.submit();
}

function getChild(f, sObj) {
	if (sObj.value) {
		f.elements['mode'].value = 'get_child';
		f.submit();
	}
}

function getChild2(f, sObj) {
	if (sObj.value) {
		f.elements['mode'].value = 'get_child2';
		f.submit();
	}
}

function getName(sObj,n) {
	if(sObj.value) {		
		var sName = sObj.options[sObj.selectedIndex].text;
		//alert(sObj.getAttribute('id').indexOf(2));
		//var sNo = (sObj.getAttribute('id').indexOf(1) >= 0 ) ? 1 : 2 ;
		document.getElementById('lentcat'+n).value = sName;
	}
}

function MoveUp(obj_no) {
    var combo = document.getElementById('lentsel'+obj_no);
    var i = combo.selectedIndex;
    if ( i > 0 ) {
        swap(combo, i, i-1);
        combo.options[i-1].selected = true;
        combo.options[i].selected = false;
		sortCat(combo, 'up', i);
    }	
}

function MoveDown(obj_no) {
    var combo = document.getElementById('lentsel'+obj_no);
    var i = combo.selectedIndex;

    if ( i < combo.length - 1 && i > -1 ) {
        swap(combo,i+1,i);
        combo.options[i+1].selected = true;
        combo.options[i].selected = false;
		sortCat(combo,'down',i);
    }
}

function swap(combo,index1, index2) {
    var savedValue = combo.options[index1].value;
    var savedText = combo.options[index1].text;

    combo.options[index1].value = combo.options[index2].value;
    combo.options[index1].text = combo.options[index2].text;

    combo.options[index2].value = savedValue;
    combo.options[index2].text = savedText;
}

function sortCat(sObj,mode,tg) {
	var tForm = document.catTargetForm;	
	if ( mode == 'up' ) {
		tForm.code1.value = sObj.options[tg-1].value;
		tForm.code2.value = sObj.options[tg].value;
		tForm.mode.value = mode;
		tForm.submit();
		tForm.reset();
	}
	else if ( mode == 'down' ) {
		tForm.code1.value = sObj.options[tg].value;
		tForm.code2.value = sObj.options[tg+1].value;		
		tForm.mode.value = mode;
		tForm.submit();
		tForm.reset();
	}
}

function htmlspecialchars_decode (string, quote_style) {
  var optTemp = 0,
    i = 0,
    noquotes = false;
  if (typeof quote_style === 'undefined') {
    quote_style = 2;
  }
  string = string.toString().replace(/&lt;/g, '<').replace(/&gt;/g, '>');
  var OPTS = {
    'ENT_NOQUOTES': 0,
    'ENT_HTML_QUOTE_SINGLE': 1,
    'ENT_HTML_QUOTE_DOUBLE': 2,
    'ENT_COMPAT': 2,
    'ENT_QUOTES': 3,
    'ENT_IGNORE': 4
  };
  if (quote_style === 0) {
    noquotes = true;
  }
  if (typeof quote_style !== 'number') { // Allow for a single string or an array of string flags
    quote_style = [].concat(quote_style);
    for (i = 0; i < quote_style.length; i++) {
      // Resolve string input to bitwise e.g. 'PATHINFO_EXTENSION' becomes 4
      if (OPTS[quote_style[i]] === 0) {
        noquotes = true;
      } else if (OPTS[quote_style[i]]) {
        optTemp = optTemp | OPTS[quote_style[i]];
      }
    }
    quote_style = optTemp;
  }
  if (quote_style & OPTS.ENT_HTML_QUOTE_SINGLE) {
    string = string.replace(/&#0*39;/g, "'"); // PHP doesn't currently escape if more than one 0, but it should
    // string = string.replace(/&apos;|&#x0*27;/g, "'"); // This would also be useful here, but not a part of PHP
  }
  if (!noquotes) {
    string = string.replace(/&quot;/g, '"');
  }
  // Put this in last place to avoid escape being double-decoded
  string = string.replace(/&amp;/g, '&');

  return string;
}
//base64_encode
function mencode(data) {


  var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
    ac = 0,
    enc = '',
    tmp_arr = [];

  if (!data) {
    return data;
  }

  do { // pack three octets into four hexets
    o1 = data.charCodeAt(i++);
    o2 = data.charCodeAt(i++);
    o3 = data.charCodeAt(i++);

    bits = o1 << 16 | o2 << 8 | o3;

    h1 = bits >> 18 & 0x3f;
    h2 = bits >> 12 & 0x3f;
    h3 = bits >> 6 & 0x3f;
    h4 = bits & 0x3f;

    // use hexets to index into b64, and append result to encoded string
    tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
  } while (i < data.length);

  enc = tmp_arr.join('');

  var r = data.length % 3;

  return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
}

function mdecode (data) {

  var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
    ac = 0,
    dec = "",
    tmp_arr = [];

  if (!data) {
    return data;
  }

  data += '';

  do { // unpack four hexets into three octets using index points in b64
    h1 = b64.indexOf(data.charAt(i++));
    h2 = b64.indexOf(data.charAt(i++));
    h3 = b64.indexOf(data.charAt(i++));
    h4 = b64.indexOf(data.charAt(i++));

    bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

    o1 = bits >> 16 & 0xff;
    o2 = bits >> 8 & 0xff;
    o3 = bits & 0xff;

    if (h3 == 64) {
      tmp_arr[ac++] = String.fromCharCode(o1);
    } else if (h4 == 64) {
      tmp_arr[ac++] = String.fromCharCode(o1, o2);
    } else {
      tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
    }
  } while (i < data.length);

  dec = tmp_arr.join('');

  return dec;
}

function NameGetValue(n,gt,spt1,spt2)//변수,구분자,받아올 name
{
	var a=new Array();
	var b=new Array();
	
	var ch1,ch2;
	if(spt1 == "")
	{
		ch1="7hye^";
	}else{
		ch1=spt1;
	}
	
	if(spt2 == "")
	{
		ch2="5hye^";
	}else{
		ch2=spt2;
	}
	
	a=n.split(ch1);
	for(var i=0;i< a.length;i++)
	{
		b=a[i].split(ch2);
		if(b[0] == gt)
		{
			return b[1];
		}
	}
	
	return "";
}


function TableReset(TableId)
{
	$("#"+TableId+" tr").each(function(idx) {
		if(idx > 0)
		{
			$(this).remove();
		}
  	});
}

function TrAdd(TableId)
{
	var lastItemNo = $("#"+TableId+" tr:last").attr("class").replace("str", "");
   	var newitem = $("#"+TableId+" tr:eq(1)").clone();
   	newitem.removeClass();
    newitem.find("td:eq(0)").attr("rowspan", "1");
    newitem.addClass("item"+(parseInt(lastItemNo)+1));
    $("#"+TableId).append(newitem);
}

function TrDel(TrId)
{

	var clickedRow = $(TrId).parent().parent();
    var cls = clickedRow.attr("class");
      	          
   /*if( clickedRow.find("td:eq(0)").attr("rowspan") )
   {
   		if( clickedRow.next().hasClass(cls) )
   		{
			clickedRow.next().prepend(clickedRow.find("td:eq(0)"));
        }
	}
 */
     clickedRow.remove();
     //resizeRowspan(cls);
}

function resizeRowspan(cls)
{
	var rowspan = $("."+cls).length;
	$("."+cls+":first td:eq(0)").attr("rowspan", rowspan);
}


function PageList(n)
{
	location.href=n;
}

function FileDown(n)
{
	actionFrame.location.href='/_ma_inc/CommonDown.php?seq='+n;
	
}

function FileDownSelf(table,n,field)
{
	actionFrame.location.href='/_ma_inc/CommonDownSelf.php?table='+table+'&seq='+n+'&field='+field;
}



function layer_open(el){
	var temp = $('#' + el);

	var bg = temp.prev().hasClass('bg');	//dimmed 레이어를 감지하기 위한 boolean 변수

	if(bg){
		$('#' + el).parent().fadeIn();	//'bg' 클래스가 존재하면 레이어가 나타나고 배경은 dimmed 된다. 
	}else{
		temp.fadeIn();
	}

		// 화면의 중앙에 레이어를 띄운다.
		if (temp.outerHeight() < $(document).height() ) temp.css('margin-top', '-'+temp.outerHeight()/2+'px');
		else temp.css('top', '0px');
		if (temp.outerWidth() < $(document).width() ) temp.css('margin-left', '-'+temp.outerWidth()/2+'px');
		else temp.css('left', '0px');

		temp.find('a.cbtn').click(function(e){
			if(bg){
				$('#' + el).parent().fadeOut(); //'bg' 클래스가 존재하면 레이어를 사라지게 한다. 
			}else{
				temp.fadeOut();
			}
			e.preventDefault();
		});
		
		temp.find('#cbtn2').click(function(e){
			if(bg){
				$('#' + el).parent().fadeOut(); //'bg' 클래스가 존재하면 레이어를 사라지게 한다. 
			}else{
				temp.fadeOut();
			}
			e.preventDefault();
			
			var f=document.regForm;
			var f2=document.regForm2;
			
			f2.user_name.value=f.user_name.value;
			f2.id_email_11.value=f.id_email_11.value;
			f2.id_email_12.value=f.id_email_12.value;
			$('#find_pw').trigger("click");
			
		});
		
		

		$('.layer .bg').click(function(e){	//배경을 클릭하면 레이어를 사라지게 하는 이벤트 핸들러
			$('.layer').fadeOut();
			e.preventDefault();
		});
}

function randomjs() {
 //var ranval = Math.random(); // 0.xxxxx 형식의 숫자를 생성시킴
  return  Math.floor(Math.random()*10999970); // 정수형의 난수를 생성

}


function gettype(mixed_var) {

  var s = typeof mixed_var,
    name;
  var getFuncName = function(fn) {
    var name = (/\W*function\s+([\w\$]+)\s*\(/)
      .exec(fn);
    if (!name) {
      return '(Anonymous)';
    }
    return name[1];
  };
  if (s === 'object') {
    if (mixed_var !== null) { // From: http://javascript.crockford.com/remedial.html
      if (typeof mixed_var.length === 'number' && !(mixed_var.propertyIsEnumerable('length')) && typeof mixed_var
        .splice === 'function') {
        s = 'array';
      } else if (mixed_var.constructor && getFuncName(mixed_var.constructor)) {
        name = getFuncName(mixed_var.constructor);
        if (name === 'Date') {
          s = 'date'; // not in PHP
        } else if (name === 'RegExp') {
          s = 'regexp'; // not in PHP
        } else if (name === 'PHPJS_Resource') { // Check against our own resource constructor
          s = 'resource';
        }
      }
    } else {
      s = 'null';
    }
  } else if (s === 'number') {
    s = this.is_float(mixed_var) ? 'double' : 'integer';
  }
  return s;
}

function strval(str) {


  var type = '';

  if (str === null) {
    return '';
  }

  type = this.gettype(str);

  switch (type) {
    case 'boolean':
      if (str === true) {
        return '1';
      }
      return '';
    case 'array':
      return 'Array';
    case 'object':
      return 'Object';
  }

  return str;
}

function strlen(string) {


  var str = string + '';
  var i = 0,
    chr = '',
    lgth = 0;

  if (!this.php_js || !this.php_js.ini || !this.php_js.ini['unicode.semantics'] || this.php_js.ini[
    'unicode.semantics'].local_value.toLowerCase() !== 'on') {
    return string.length;
  }

  var getWholeChar = function(str, i) {
    var code = str.charCodeAt(i);
    var next = '',
      prev = '';
    if (0xD800 <= code && code <= 0xDBFF) { // High surrogate (could change last hex to 0xDB7F to treat high private surrogates as single characters)
      if (str.length <= (i + 1)) {
        throw 'High surrogate without following low surrogate';
      }
      next = str.charCodeAt(i + 1);
      if (0xDC00 > next || next > 0xDFFF) {
        throw 'High surrogate without following low surrogate';
      }
      return str.charAt(i) + str.charAt(i + 1);
    } else if (0xDC00 <= code && code <= 0xDFFF) { // Low surrogate
      if (i === 0) {
        throw 'Low surrogate without preceding high surrogate';
      }
      prev = str.charCodeAt(i - 1);
      if (0xD800 > prev || prev > 0xDBFF) { //(could change last hex to 0xDB7F to treat high private surrogates as single characters)
        throw 'Low surrogate without preceding high surrogate';
      }
      return false; // We can pass over low surrogates now as the second component in a pair which we have already processed
    }
    return str.charAt(i);
  };

  for (i = 0, lgth = 0; i < str.length; i++) {
    if ((chr = getWholeChar(str, i)) === false) {
      continue;
    } // Adapt this line at the top of any loop, passing in the whole string and the current iteration and returning a variable to represent the individual character; purpose is to treat the first part of a surrogate pair as the whole character and then ignore the second part
    lgth++;
  }
  return lgth;
}

function ord(string) {

  var str = string + '',
    code = str.charCodeAt(0);
  if (0xD800 <= code && code <= 0xDBFF) { // High surrogate (could change last hex to 0xDB7F to treat high private surrogates as single characters)
    var hi = code;
    if (str.length === 1) {
      return code; // This is just a high surrogate with no following low surrogate, so we return its value;
      // we could also throw an error as it is not a complete character, but someone may want to know
    }
    var low = str.charCodeAt(1);
    return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
  }
  if (0xDC00 <= code && code <= 0xDFFF) { // Low surrogate
    return code; // This is just a low surrogate with no preceding high surrogate, so we return its value;
    // we could also throw an error as it is not a complete character, but someone may want to know
  }
  return code;
}

function chr(codePt) {

  if (codePt > 0xFFFF) { // Create a four-byte string (length 2) since this code point is high
    //   enough for the UTF-16 encoding (JavaScript internal use), to
    //   require representation with two surrogates (reserved non-characters
    //   used for building other characters; the first is "high" and the next "low")
    codePt -= 0x10000;
    return String.fromCharCode(0xD800 + (codePt >> 10), 0xDC00 + (codePt & 0x3FF));
  }
  return String.fromCharCode(codePt);
}


function base64_encode(data) {


  var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
    ac = 0,
    enc = '',
    tmp_arr = [];

  if (!data) {
    return data;
  }

  do { // pack three octets into four hexets
    o1 = data.charCodeAt(i++);
    o2 = data.charCodeAt(i++);
    o3 = data.charCodeAt(i++);

    bits = o1 << 16 | o2 << 8 | o3;

    h1 = bits >> 18 & 0x3f;
    h2 = bits >> 12 & 0x3f;
    h3 = bits >> 6 & 0x3f;
    h4 = bits & 0x3f;

    // use hexets to index into b64, and append result to encoded string
    tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
  } while (i < data.length);

  enc = tmp_arr.join('');

  var r = data.length % 3;

  return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
}

function bin2hex(s) {

  var i, l, o = '',
    n;

  s += '';

  for (i = 0, l = s.length; i < l; i++) {
    n = s.charCodeAt(i)
      .toString(16);
    o += n.length < 2 ? '0' + n : n;
  }

  return o;
}
function pack(format) {
  //  discuss at: http://phpjs.org/functions/pack/
  // original by: Tim de Koning (http://www.kingsquare.nl)
  //    parts by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // bugfixed by: Tim de Koning (http://www.kingsquare.nl)
  //        note: Float encoding by: Jonas Raoni Soares Silva
  //        note: Home: http://www.kingsquare.nl/blog/12-12-2009/13507444
  //        note: Feedback: phpjs-pack@kingsquare.nl
  //        note: 'machine dependent byte order and size' aren't
  //        note: applicable for JavaScript; pack works as on a 32bit,
  //        note: little endian machine
  //   example 1: pack('nvc*', 0x1234, 0x5678, 65, 66);
  //   returns 1: '4xVAB'

  var formatPointer = 0,
    argumentPointer = 1,
    result = '',
    argument = '',
    i = 0,
    r = [],
    instruction, quantifier, word, precisionBits, exponentBits, extraNullCount;

  // vars used by float encoding
  var bias, minExp, maxExp, minUnnormExp, status, exp, len, bin, signal, n, intPart, floatPart, lastBit, rounded, j,
    k, tmpResult;

  while (formatPointer < format.length) {
    instruction = format.charAt(formatPointer);
    quantifier = '';
    formatPointer++;
    while ((formatPointer < format.length) && (format.charAt(formatPointer)
      .match(/[\d\*]/) !== null)) {
      quantifier += format.charAt(formatPointer);
      formatPointer++;
    }
    if (quantifier === '') {
      quantifier = '1';
    }

    // Now pack variables: 'quantifier' times 'instruction'
    switch (instruction) {
      case 'a':
        // NUL-padded string
      case 'A':
        // SPACE-padded string
        if (typeof arguments[argumentPointer] === 'undefined') {
          throw new Error('Warning:  pack() Type ' + instruction + ': not enough arguments');
        } else {
          argument = String(arguments[argumentPointer]);
        }
        if (quantifier === '*') {
          quantifier = argument.length;
        }
        for (i = 0; i < quantifier; i++) {
          if (typeof argument[i] === 'undefined') {
            if (instruction === 'a') {
              result += String.fromCharCode(0);
            } else {
              result += ' ';
            }
          } else {
            result += argument[i];
          }
        }
        argumentPointer++;
        break;
      case 'h':
        // Hex string, low nibble first
      case 'H':
        // Hex string, high nibble first
        if (typeof arguments[argumentPointer] === 'undefined') {
          throw new Error('Warning: pack() Type ' + instruction + ': not enough arguments');
        } else {
          argument = arguments[argumentPointer];
        }
        if (quantifier === '*') {
          quantifier = argument.length;
        }
        if (quantifier > argument.length) {
          throw new Error('Warning: pack() Type ' + instruction + ': not enough characters in string');
        }
        for (i = 0; i < quantifier; i += 2) {
          // Always get per 2 bytes...
          word = argument[i];
          if (((i + 1) >= quantifier) || typeof argument[i + 1] === 'undefined') {
            word += '0';
          } else {
            word += argument[i + 1];
          }
          // The fastest way to reverse?
          if (instruction === 'h') {
            word = word[1] + word[0];
          }
          result += String.fromCharCode(parseInt(word, 16));
        }
        argumentPointer++;
        break;

      case 'c':
        // signed char
      case 'C':
        // unsigned char
        // c and C is the same in pack
        if (quantifier === '*') {
          quantifier = arguments.length - argumentPointer;
        }
        if (quantifier > (arguments.length - argumentPointer)) {
          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');
        }

        for (i = 0; i < quantifier; i++) {
          result += String.fromCharCode(arguments[argumentPointer]);
          argumentPointer++;
        }
        break;

      case 's':
        // signed short (always 16 bit, machine byte order)
      case 'S':
        // unsigned short (always 16 bit, machine byte order)
      case 'v':
        // s and S is the same in pack
        if (quantifier === '*') {
          quantifier = arguments.length - argumentPointer;
        }
        if (quantifier > (arguments.length - argumentPointer)) {
          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');
        }

        for (i = 0; i < quantifier; i++) {
          result += String.fromCharCode(arguments[argumentPointer] & 0xFF);
          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF);
          argumentPointer++;
        }
        break;

      case 'n':
        // unsigned short (always 16 bit, big endian byte order)
        if (quantifier === '*') {
          quantifier = arguments.length - argumentPointer;
        }
        if (quantifier > (arguments.length - argumentPointer)) {
          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');
        }

        for (i = 0; i < quantifier; i++) {
          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF);
          result += String.fromCharCode(arguments[argumentPointer] & 0xFF);
          argumentPointer++;
        }
        break;

      case 'i':
        // signed integer (machine dependent size and byte order)
      case 'I':
        // unsigned integer (machine dependent size and byte order)
      case 'l':
        // signed long (always 32 bit, machine byte order)
      case 'L':
        // unsigned long (always 32 bit, machine byte order)
      case 'V':
        // unsigned long (always 32 bit, little endian byte order)
        if (quantifier === '*') {
          quantifier = arguments.length - argumentPointer;
        }
        if (quantifier > (arguments.length - argumentPointer)) {
          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');
        }

        for (i = 0; i < quantifier; i++) {
          result += String.fromCharCode(arguments[argumentPointer] & 0xFF);
          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF);
          result += String.fromCharCode(arguments[argumentPointer] >> 16 & 0xFF);
          result += String.fromCharCode(arguments[argumentPointer] >> 24 & 0xFF);
          argumentPointer++;
        }

        break;
      case 'N':
        // unsigned long (always 32 bit, big endian byte order)
        if (quantifier === '*') {
          quantifier = arguments.length - argumentPointer;
        }
        if (quantifier > (arguments.length - argumentPointer)) {
          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');
        }

        for (i = 0; i < quantifier; i++) {
          result += String.fromCharCode(arguments[argumentPointer] >> 24 & 0xFF);
          result += String.fromCharCode(arguments[argumentPointer] >> 16 & 0xFF);
          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF);
          result += String.fromCharCode(arguments[argumentPointer] & 0xFF);
          argumentPointer++;
        }
        break;

      case 'f':
        // float (machine dependent size and representation)
      case 'd':
        // double (machine dependent size and representation)
        // version original by IEEE754
        precisionBits = 23;
        exponentBits = 8;
        if (instruction === 'd') {
          precisionBits = 52;
          exponentBits = 11;
        }

        if (quantifier === '*') {
          quantifier = arguments.length - argumentPointer;
        }
        if (quantifier > (arguments.length - argumentPointer)) {
          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');
        }
        for (i = 0; i < quantifier; i++) {
          argument = arguments[argumentPointer];
          bias = Math.pow(2, exponentBits - 1) - 1;
          minExp = -bias + 1;
          maxExp = bias;
          minUnnormExp = minExp - precisionBits;
          status = isNaN(n = parseFloat(argument)) || n === -Infinity || n === +Infinity ? n : 0;
          exp = 0;
          len = 2 * bias + 1 + precisionBits + 3;
          bin = new Array(len);
          signal = (n = status !== 0 ? 0 : n) < 0;
          n = Math.abs(n);
          intPart = Math.floor(n);
          floatPart = n - intPart;

          for (k = len; k;) {
            bin[--k] = 0;
          }
          for (k = bias + 2; intPart && k;) {
            bin[--k] = intPart % 2;
            intPart = Math.floor(intPart / 2);
          }
          for (k = bias + 1; floatPart > 0 && k; --floatPart) {
            (bin[++k] = ((floatPart *= 2) >= 1) - 0);
          }
          for (k = -1; ++k < len && !bin[k];) {}

          if (bin[(lastBit = precisionBits - 1 + (k = (exp = bias + 1 - k) >= minExp && exp <= maxExp ? k + 1 :
            bias + 1 - (exp = minExp - 1))) + 1]) {
            if (!(rounded = bin[lastBit])) {
              for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]) {}
            }
            for (j = lastBit + 1; rounded && --j >= 0;
              (bin[j] = !bin[j] - 0) && (rounded = 0)) {}
          }

          for (k = k - 2 < 0 ? -1 : k - 3; ++k < len && !bin[k];) {}

          if ((exp = bias + 1 - k) >= minExp && exp <= maxExp) {
            ++k;
          } else {
            if (exp < minExp) {
              if (exp !== bias + 1 - len && exp < minUnnormExp) { }
              k = bias + 1 - (exp = minExp - 1);
            }
          }

          if (intPart || status !== 0) {
            exp = maxExp + 1;
            k = bias + 2;
            if (status === -Infinity) {
              signal = 1;
            } else if (isNaN(status)) {
              bin[k] = 1;
            }
          }

          n = Math.abs(exp + bias);
          tmpResult = '';

          for (j = exponentBits + 1; --j;) {
            tmpResult = (n % 2) + tmpResult;
            n = n >>= 1;
          }

          n = 0;
          j = 0;
          k = (tmpResult = (signal ? '1' : '0') + tmpResult + bin.slice(k, k + precisionBits)
            .join(''))
            .length;
          r = [];

          for (; k;) {
            n += (1 << j) * tmpResult.charAt(--k);
            if (j === 7) {
              r[r.length] = String.fromCharCode(n);
              n = 0;
            }
            j = (j + 1) % 8;
          }

          r[r.length] = n ? String.fromCharCode(n) : '';
          result += r.join('');
          argumentPointer++;
        }
        break;

      case 'x':
        // NUL byte
        if (quantifier === '*') {
          throw new Error('Warning: pack(): Type x: \'*\' ignored');
        }
        for (i = 0; i < quantifier; i++) {
          result += String.fromCharCode(0);
        }
        break;

      case 'X':
        // Back up one byte
        if (quantifier === '*') {
          throw new Error('Warning: pack(): Type X: \'*\' ignored');
        }
        for (i = 0; i < quantifier; i++) {
          if (result.length === 0) {
            throw new Error('Warning: pack(): Type X:' + ' outside of string');
          } else {
            result = result.substring(0, result.length - 1);
          }
        }
        break;

      case '@':
        // NUL-fill to absolute position
        if (quantifier === '*') {
          throw new Error('Warning: pack(): Type X: \'*\' ignored');
        }
        if (quantifier > result.length) {
          extraNullCount = quantifier - result.length;
          for (i = 0; i < extraNullCount; i++) {
            result += String.fromCharCode(0);
          }
        }
        if (quantifier < result.length) {
          result = result.substring(0, quantifier);
        }
        break;

      default:
        throw new Error('Warning:  pack() Type ' + instruction + ': unknown format code');
    }
  }
  if (argumentPointer < arguments.length) {
    throw new Error('Warning: pack(): ' + (arguments.length - argumentPointer) + ' arguments unused');
  }

  return result;
}

function substr(str, start, len) {

  var i = 0,
    allBMP = true,
    es = 0,
    el = 0,
    se = 0,
    ret = '';
  str += '';
  var end = str.length;

  // BEGIN REDUNDANT
  this.php_js = this.php_js || {};
  this.php_js.ini = this.php_js.ini || {};
  // END REDUNDANT
  switch ((this.php_js.ini['unicode.semantics'] && this.php_js.ini['unicode.semantics'].local_value.toLowerCase())) {
    case 'on':
      // Full-blown Unicode including non-Basic-Multilingual-Plane characters
      // strlen()
      for (i = 0; i < str.length; i++) {
        if (/[\uD800-\uDBFF]/.test(str.charAt(i)) && /[\uDC00-\uDFFF]/.test(str.charAt(i + 1))) {
          allBMP = false;
          break;
        }
      }

      if (!allBMP) {
        if (start < 0) {
          for (i = end - 1, es = (start += end); i >= es; i--) {
            if (/[\uDC00-\uDFFF]/.test(str.charAt(i)) && /[\uD800-\uDBFF]/.test(str.charAt(i - 1))) {
              start--;
              es--;
            }
          }
        } else {
          var surrogatePairs = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
          while ((surrogatePairs.exec(str)) != null) {
            var li = surrogatePairs.lastIndex;
            if (li - 2 < start) {
              start++;
            } else {
              break;
            }
          }
        }

        if (start >= end || start < 0) {
          return false;
        }
        if (len < 0) {
          for (i = end - 1, el = (end += len); i >= el; i--) {
            if (/[\uDC00-\uDFFF]/.test(str.charAt(i)) && /[\uD800-\uDBFF]/.test(str.charAt(i - 1))) {
              end--;
              el--;
            }
          }
          if (start > end) {
            return false;
          }
          return str.slice(start, end);
        } else {
          se = start + len;
          for (i = start; i < se; i++) {
            ret += str.charAt(i);
            if (/[\uD800-\uDBFF]/.test(str.charAt(i)) && /[\uDC00-\uDFFF]/.test(str.charAt(i + 1))) {
              se++; // Go one further, since one of the "characters" is part of a surrogate pair
            }
          }
          return ret;
        }
        break;
      }
      // Fall-through
    case 'off':
      // assumes there are no non-BMP characters;
      //    if there may be such characters, then it is best to turn it on (critical in true XHTML/XML)
    default:
      if (start < 0) {
        start += end;
      }
      end = typeof len === 'undefined' ? end : (len < 0 ? len + end : len + start);
      // PHP returns false if start does not fall within the string.
      // PHP returns false if the calculated end comes before the calculated start.
      // PHP returns an empty string if start and end are the same.
      // Otherwise, PHP returns the portion of the string from start to end.
      return start >= str.length || start < 0 || start > end ? !1 : str.slice(start, end);
  }
  return undefined; // Please Netbeans
}

function base64_decode(data) {
  var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
    ac = 0,
    dec = '',
    tmp_arr = [];

  if (!data) {
    return data;
  }

  data += '';

  do { // unpack four hexets into three octets using index points in b64
    h1 = b64.indexOf(data.charAt(i++));
    h2 = b64.indexOf(data.charAt(i++));
    h3 = b64.indexOf(data.charAt(i++));
    h4 = b64.indexOf(data.charAt(i++));

    bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

    o1 = bits >> 16 & 0xff;
    o2 = bits >> 8 & 0xff;
    o3 = bits & 0xff;

    if (h3 == 64) {
      tmp_arr[ac++] = String.fromCharCode(o1);
    } else if (h4 == 64) {
      tmp_arr[ac++] = String.fromCharCode(o1, o2);
    } else {
      tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
    }
  } while (i < data.length);

  dec = tmp_arr.join('');

  return dec.replace(/\0+$/, '');
}

function hex2bin( str ) {
	var sbin = "";
    var len = strlen(str);
    
    for ( i = 0; i < len; i += 2 ) {
            sbin =sbin+ pack( "H*", substr( str, i, 2 ) );
    }

    return sbin;
}
    
function key_encode(sText)
{
	var tmpa=strval(sText);
    var cntData  =  strlen(tmpa)  -  1;  
    var cntCode  =  strlen(CompanyKey)  -  1;  
    
          
    var arrData  = new Array;  
    var arrCode  = new Array;  
    var sCode  = CompanyKey;
    var i;      

    for(i = 0;cntData  >=  i;  i++)
    {  
		arrData[i]  =  tmpa[i];
	}  
	
    for(i = 0;cntCode  >=  i;  i++)
    {  
    	arrCode[i]  =  sCode[i];  
    }
          
    var flag  =  0;  
   	var strResult  =  "";  

    for(i  =  0;cntData  >=  i;  i++)  {  

              	strResult  =  strResult+(ord(arrData[i])  ^  ord(arrCode[flag])) + chr(8);  

                if(flag  ==  cntCode)  
                        flag  =  0;  
                else  
                        flag++;  
        }  

        return   bin2hex(base64_encode(strResult));  
}

function explode(delimiter, string, limit) {


  if (arguments.length < 2 || typeof delimiter === 'undefined' || typeof string === 'undefined') return null;
  if (delimiter === '' || delimiter === false || delimiter === null) return false;
  if (typeof delimiter === 'function' || typeof delimiter === 'object' || typeof string === 'function' || typeof string ===
    'object') {
    return {
      0: ''
    };
  }
  if (delimiter === true) delimiter = '1';

  // Here we go...
  delimiter += '';
  string += '';

  var s = string.split(delimiter);

  if (typeof limit === 'undefined') return s;

  // Support for limit
  if (limit === 0) limit = 1;

  // Positive limit
  if (limit > 0) {
    if (limit >= s.length) return s;
    return s.slice(0, limit - 1)
      .concat([s.slice(limit - 1)
        .join(delimiter)
      ]);
  }

  // Negative limit
  if (-limit >= s.length) return [];

  s.splice(s.length + limit);
  return s;
}

function count(mixed_var, mode) {

  var key, cnt = 0;

  if (mixed_var === null || typeof mixed_var === 'undefined') {
    return 0;
  } else if (mixed_var.constructor !== Array && mixed_var.constructor !== Object) {
    return 1;
  }

  if (mode === 'COUNT_RECURSIVE') {
    mode = 1;
  }
  if (mode != 1) {
    mode = 0;
  }

  for (key in mixed_var) {
    if (mixed_var.hasOwnProperty(key)) {
      cnt++;
      if (mode == 1 && mixed_var[key] && (mixed_var[key].constructor === Array || mixed_var[key].constructor ===
        Object)) {
        cnt += this.count(mixed_var[key], 1);
      }
    }
  }

  return cnt;
}

function  key_decode(sText)  {  

		var sCode  = CompanyKey;
		var arrData  = new Array;  
    	var arrCode  = new Array;  
    	var i;
    
        sText  =  base64_decode(hex2bin(sText));  
          
       	arrData  =  explode(chr(8),  sText);  

        var cntData  =  count(arrData)  -  2;  
       var cntCode  =  strlen(sCode)  -  1;  
          
        for(i  =  0;  cntCode  >=  i;  i++)  
                arrCode[i]  =  sCode[i];  
          
        var flag  =  0;  
        var strResult  =  "";  

        for(i  =  0;cntData  >=  i;  i++)  {  
                strResult  =  strResult +chr((arrData[i])  ^  ord(arrCode[flag]));  
                  
                if(flag  ==  cntCode)  
                        flag  =  0;  
                else  
                        flag++;  
        }  

        return  strResult;  
}  
//즐겨찾기
function addFavorite(){

if (window.sidebar && window.sidebar.addPanel){ // Firefox 
	window.sidebar.addPanel(sidebartitle, sidebarurl,""); 
}else if ( document.all ) { // IE Favorite 
	window.external.AddFavorite(url, title); 
}else if (window.opera && window.print) { 
// do nothing 
}else if (navigator.appName=="Netscape") { 
	alert("Please click OK, then press <Ctrl-D> to bookmark this page."); 
} 
 

 if (window.sidebar && window.sidebar.addPanel) { 
  document.write('<a href = "javascript:addFavorite();" style="color:#A7A9AC;">즐겨찿기</a>'); 
  } 
 else if (document.all) { 
  document.write('<a href = "javascript:addFavorite();" style="color:#A7A9AC;">즐겨찿기</a>'); 
 } 
 else if (window.opera && window.print) { 
document.write('<a href = "'+sidebarurl+'" title="'+sidebartitle+'" rel="sidebar" style="color:#A7A9AC;">즐겨찿기</a>'); 
 } 
 else if (navigator.appName=="Netscape") { 
  document.write('<a href = "javascript:addFavorite();" style="color:#A7A9AC;">즐겨찿기</a>'); 
} 
}

function autoHypenPhone(str){
	str = str.replace(/[^0-9]/g, '');
	if(str.substr(0,2) == "02")
	{
	
	var tmp = '';
	if( str.length < 3){
		return str;
	}else if(str.length < 6){
		tmp += str.substr(0, 2);
		tmp += '-';
		tmp += str.substr(2);
		return tmp;
	}else if(str.length < 10){
		tmp += str.substr(0, 2);
		tmp += '-';
		tmp += str.substr(2, 3);
		tmp += '-';
		tmp += str.substr(5);
		return tmp;
	}else{				
		tmp += str.substr(0, 2);
		tmp += '-';
		tmp += str.substr(2, 4);
		tmp += '-';
		tmp += str.substr(6);
		return tmp;
	}
	}else{
	
	var tmp = '';
	if( str.length < 4){
		return str;
	}else if(str.length < 7){
		tmp += str.substr(0, 3);
		tmp += '-';
		tmp += str.substr(3);
		return tmp;
	}else if(str.length < 11){
		tmp += str.substr(0, 3);
		tmp += '-';
		tmp += str.substr(3, 3);
		tmp += '-';
		tmp += str.substr(6);
		return tmp;
	}else{				
		tmp += str.substr(0, 3);
		tmp += '-';
		tmp += str.substr(3, 4);
		tmp += '-';
		tmp += str.substr(7);
		return tmp;
	}
	}
	return str;
}


function autoHypenBirth(str){
	str = str.replace(/[^0-9]/g, '');
	var tmp = '';
	if( str.length < 4){
		tmp=str;
	}else if(str.length < 6){
		tmp += str.substr(0, 4);
		tmp += '-';
		tmp += str.substr(4);
	}else{
		tmp += str.substr(0, 4);
		tmp += '-';
		tmp += str.substr(4, 2);
		tmp += '-';
		tmp += str.substr(6,2);
		
	}
	return tmp;
	//return str;
}

function autoHypenBizCode(str){
	str = str.replace(/[^0-9]/g, '');
	var tmp = '';
	if( str.length < 3){
		tmp=str;
	}else if(str.length < 5){
		tmp += str.substr(0, 3);
		tmp += '-';
		tmp += str.substr(3);
	}else{
		tmp += str.substr(0, 3);
		tmp += '-';
		tmp += str.substr(3, 2);
		tmp += '-';
		tmp += str.substr(5,10);
		
	}
	return tmp;
	//return str;
}

function trunc(str,digit) {
	var a=str.toString();

	var a=a.substr(0,a.length-digit);
	
	for(var i=0;i<digit;i++)
	{
		a=a+"0";
	}	
	return a;
}

function roundDown(number, decimals) {
    decimals = decimals || 0;
    return ( Math.floor( number * Math.pow(10, decimals) ) / Math.pow(10, decimals) );
}

//개행문자 제거

function rn_remove(str)
{
	var out="";
	if(!str)
	{
		return "";
	}
	str=str.toString();
	if( (str == "") || (str.length < 1))
	{
		return "";
	}
	
	out = str.replace(/\s+/, "");//왼쪽 공백제거
	out = out.replace(/\s+$/g, "");//오른쪽 공백제거
	out = out.replace(/\n/g, "");//행바꿈제거
	out = out.replace(/\r/g, "");//엔터제거
	
	return out;	
}

function space_remove(str)
{
	var out="";
	if(!str)
	{
		return "";
	}
	str=str.toString();
	if( (str == "") || (str.length < 1))
	{
		return "";
	}
	
	out = str.replace(/\s/, "");//왼쪽 공백제거
	
	return out;	
}

function val_exist(val)//변수가 존재하는 
{
	if(val)
	{
		return val;
	}else{
		return "";
	}
}

function uploadImage(image,obj) {
    var data = new FormData();
    data.append("image",image);
    $.ajax ({
        data: data,
        type: "POST",
        url: "/_ma_post/imgUp.php",
        cache: false,
        contentType: false,
        processData: false,
        success: function(url) {
            var image = url;
            obj.summernote('insertImage', image);
			
            },
            error: function(data) {
               
            }
        });
}

function kin4(str, max){ 
    if(!max) max = 4; // 글자수를 지정하지 않으면 4로 지정 
    var i, j, k, x, y; 
    var buff = ["0123456789", "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"]; 
    var src, src2, ptn=""; 

    for(i=0; i<buff.length; i++){ 
        src = buff[i]; // 0123456789 
        src2 = buff[i] + buff[i]; // 01234567890123456789 
        for(j=0; j<src.length; j++){ 
            x = src.substr(j, 1); // 0 
            y = src2.substr(j, max); // 0123 
            ptn += "["+x+"]{"+max+",}|"; // [0]{4,}|0123|[1]{4,}|1234|... 
            ptn += y+"|"; 
        } 
    } 
    ptn = new RegExp(ptn.replace(/.$/, "")); // 맨마지막의 글자를 하나 없애고 정규식으로 만든다. 

    if(ptn.test(str)) return true; 
    return false; 
} 

function chkPwd(str){
	var pw = str;
	var num = pw.search(/[0-9]/g);
	var eng = pw.search(/[a-z]/ig);
	var spe = pw.search(/[`~!@@#$%^&*|₩₩₩'₩";:₩/?]/gi);

	if(pw.length < 8 || pw.length > 20){
		alert("비밀번호는 8자리 ~ 20자리 이내로 입력해주세요.");
		return false;
	}

	if(pw.search(/₩s/) != -1){
		alert("비밀번호는 공백업이 입력해주세요.");
		return false;

	} 
	if(num < 0 || eng < 0 || spe < 0 ){
		alert("비밀번호는 영문,숫자, 특수문자를 혼합하여 입력해주세요.");
	return false;
	}
	return true;

}

function email_check(str) {		

    var email = str;
    var exptext = /^[A-Za-z0-9_\.\-]+@[A-Za-z0-9\-]+\.[A-Za-z0-9\-]+/;
    if(exptext.test(email)==false){		
        return false;
    }		
    return true;
}
// 도메인 체크
function ValidUrl(str) {

  var pattern = new RegExp('^(https?:\\/\\/)?'+ // protocol
  '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|'+ // domain name
  '((\\d{1,3}\\.){3}\\d{1,3}))'+ // OR ip (v4) address
  '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*'+ // port and path
  '(\\?[;&a-z\\d%_.~+=-]*)?'+ // query string
  '(\\#[-a-z\\d_]*)?$','i'); // fragment locator

  if(!pattern.test(str)) {

    return false;

  } else {

    return true;

  }

}

function onlyNumber(obj) {
    $(obj).keyup(function(){
         $(this).val($(this).val().replace(/[^0-9\.]/g,""));
    }); 
}

function strip_tags(str)
{
	str = str.replace(/<(\/)?([a-zA-Z]*)(\s[a-zA-Z]*=[^>]*)?(\s)*(\/)?>/ig, "");
	return str;
}
//		










